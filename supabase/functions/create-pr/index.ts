import "jsr:@supabase/functions-js/edge-runtime.d.ts";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "POST, OPTIONS",
  "Access-Control-Allow-Headers": "Content-Type, Authorization, X-Client-Info, Apikey",
};

interface CreatePRRequest {
  githubToken: string;
  repoOwner: string;
  repoName: string;
  issue: {
    id: string;
    severity: string;
    category: string;
    title: string;
    description: string;
    filePath?: string;
  };
  fix: {
    file_path: string;
    fixed_content: string;
    explanation: string;
  };
}

Deno.serve(async (req: Request) => {
  if (req.method === "OPTIONS") {
    return new Response(null, {
      status: 200,
      headers: corsHeaders,
    });
  }

  try {
    if (req.method !== "POST") {
      return new Response(
        JSON.stringify({ error: "Method not allowed" }),
        {
          status: 405,
          headers: { ...corsHeaders, "Content-Type": "application/json" },
        }
      );
    }

    const { githubToken, repoOwner, repoName, issue, fix } = await req.json() as CreatePRRequest;

    if (!githubToken || !repoOwner || !repoName || !issue || !fix) {
      return new Response(
        JSON.stringify({ error: "Missing required fields" }),
        {
          status: 400,
          headers: { ...corsHeaders, "Content-Type": "application/json" },
        }
      );
    }

    const githubApi = "https://api.github.com";
    const authHeaders = {
      "Authorization": `Bearer ${githubToken}`,
      "Accept": "application/vnd.github.v3+json",
      "Content-Type": "application/json",
    };

    // Get the default branch
    const repoResponse = await fetch(`${githubApi}/repos/${repoOwner}/${repoName}`, {
      headers: authHeaders,
    });

    if (!repoResponse.ok) {
      throw new Error(`Failed to fetch repository: ${repoResponse.statusText}`);
    }

    const repoData = await repoResponse.json();
    const defaultBranch = repoData.default_branch;

    // Get the SHA of the default branch
    const refResponse = await fetch(
      `${githubApi}/repos/${repoOwner}/${repoName}/git/refs/heads/${defaultBranch}`,
      { headers: authHeaders }
    );

    if (!refResponse.ok) {
      throw new Error(`Failed to fetch branch reference: ${refResponse.statusText}`);
    }

    const refData = await refResponse.json();
    const baseSha = refData.object.sha;

    // Create a new branch
    const branchName = `fix/security-${issue.severity}-${issue.id.substring(0, 8)}`;
    const createBranchResponse = await fetch(
      `${githubApi}/repos/${repoOwner}/${repoName}/git/refs`,
      {
        method: "POST",
        headers: authHeaders,
        body: JSON.stringify({
          ref: `refs/heads/${branchName}`,
          sha: baseSha,
        }),
      }
    );

    if (!createBranchResponse.ok) {
      const errorData = await createBranchResponse.json();
      if (errorData.message?.includes("already exists")) {
        return new Response(
          JSON.stringify({ error: "A branch for this fix already exists" }),
          {
            status: 409,
            headers: { ...corsHeaders, "Content-Type": "application/json" },
          }
        );
      }
      throw new Error(`Failed to create branch: ${createBranchResponse.statusText}`);
    }

    // Get current file content to get its SHA
    const fileResponse = await fetch(
      `${githubApi}/repos/${repoOwner}/${repoName}/contents/${fix.file_path}?ref=${defaultBranch}`,
      { headers: authHeaders }
    );

    if (!fileResponse.ok) {
      throw new Error(`Failed to fetch file: ${fileResponse.statusText}`);
    }

    const fileData = await fileResponse.json();
    const fileSha = fileData.sha;

    // Update the file with the fix
    const updateFileResponse = await fetch(
      `${githubApi}/repos/${repoOwner}/${repoName}/contents/${fix.file_path}`,
      {
        method: "PUT",
        headers: authHeaders,
        body: JSON.stringify({
          message: `Fix ${issue.severity} security issue: ${issue.title}`,
          content: btoa(fix.fixed_content),
          branch: branchName,
          sha: fileSha,
        }),
      }
    );

    if (!updateFileResponse.ok) {
      throw new Error(`Failed to update file: ${updateFileResponse.statusText}`);
    }

    // Create Pull Request
    const prTitle = `[Security] Fix ${issue.severity} issue: ${issue.title}`;
    const prBody = `## Security Fix

**Severity:** ${issue.severity.toUpperCase()}
**Category:** ${issue.category}

### Issue Description
${issue.description}

### What Changed
${fix.explanation}

### Files Modified
- \`${fix.file_path}\`

---

ðŸ”’ This PR was automatically generated by SecureAF to fix a security vulnerability.

**Please review carefully before merging!**`;

    const createPRResponse = await fetch(
      `${githubApi}/repos/${repoOwner}/${repoName}/pulls`,
      {
        method: "POST",
        headers: authHeaders,
        body: JSON.stringify({
          title: prTitle,
          body: prBody,
          head: branchName,
          base: defaultBranch,
        }),
      }
    );

    if (!createPRResponse.ok) {
      const errorData = await createPRResponse.json();
      throw new Error(`Failed to create PR: ${errorData.message || createPRResponse.statusText}`);
    }

    const prData = await createPRResponse.json();

    return new Response(
      JSON.stringify({
        success: true,
        pr: {
          url: prData.html_url,
          number: prData.number,
          branch: branchName,
          title: prData.title,
        },
      }),
      {
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      }
    );
  } catch (error) {
    console.error("PR creation error:", error);
    return new Response(
      JSON.stringify({
        error: error.message || "Failed to create pull request",
      }),
      {
        status: 500,
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      }
    );
  }
});
